#!/bin/bash

# layersnap
# 
# overlayfs- and rsync-based simple snapshots
#
# - ls_bootstrap is called at the EOF
# - ls_bootstrap calls parseRequest and calls the appropriate controller
# - controller uses helpers to do the job
#

#
# convention:
# - GlobalVariable
# - localVariable
# terminology:
# - layer: one single directory
# - snapshot: a directory with all previous layers
#
# todo
# ubuntu 12.04 syntax
# $((2 ** 4))



##############
##############
##          ##
##  ROUTER  ##
##          ##
##############
##############


#
# status, prepare, snapshot, merge or restore?
#

ls_bootstrap() { # (request)
  # parse request parameters
  parseRequest $*
  
  # set mode depending on host-system
  setMode
  
  # exit if layersnap is not supported
  if [ "$LSMode" == "0" ]
  then
    echo "ABORTING: Sorry, but your System is not capable of running layersnap."
    echo "Layersnap depends on overlayfs, which was included in kernel 3.18 and extended by support of multiple lower-layers in 4.0. Besides that, Ubuntu supports overlayfs partly since at least 12.04 and fully since at least 14.04"
    exit
  fi 

  # basic paths and vars
  TargetName="$(basename $TargetPath)"
  PoolPath="$(dirname $TargetPath)/.layersnap/$TargetName"
  DateFormat="+%s"
  DisplayDateFormat="+%d.%m.%Y %H:%M:%S"
  
  # exit with message if target is not layersnapped
  if [ ! -d "$PoolPath" ]
  then
    echo ABORTING: $TargetPath is not layersnapped, so nothing to $ACTION!
    exit
  fi
  
  # jeahjeahjeah
  case $ACTION in

    status)
      ls_status
    ;;

    snapshot)
      ls_snapshot
    ;;
    
    merge)
      ls_merge
    ;;
    
    restore)
      ls_restore
    ;;
  esac
}


###################
###################
##               ##
##  CONTROLLERS  ##
##               ##
###################
###################


# 
# show status and layers
#

ls_status() {
  setPoolVars
  
  # ensure target is mounted
  if [ ! "$PoolMounted" == "true" ]
  then
    ls_mount
    echo "layers have just been mounted."
  fi
  
  # display summerizing information
  echo "LAYERSNAP: $TargetPath consists of $(expr $LayerCount + 1) layers. $(pluralize "layer" $LayersAvailable) available."
  
  # show detailed inforamtion for each layer
  i=1
  for f in "$PoolPath/lower-"*
  do
    layerStatusLine $i $f
    i=$(expr $i + 1)
  done
  
  # show final status line for upper directory
  layerStatusLine $(expr $LayerCount + 1) $UpperPath upper
}

#
# mount pool
#

ls_mount() {
  # select mode
  case $LSMode in
    1)
      if mode1First
        mount -t overlayfs -o rw,lowerdir="$LowerList",upperdir="$UpperPath" overlayfs "$TargetPath"
      else
        mount -t overlayfs -o rw,lowerdir="$LowerList",upperdir="$UpperPath" overlayfs "$MergePath"
        mount -t overlayfs -o rw,lowerdir="$MergePath",upperdir="$UpperPath"2 overlayfs "$TargetPath"
      fi
    ;;
    2)
      mount -t overlay overlay -o rw,lowerdir="$LowerList",upperdir="$UpperPath",workdir="$WorkPath" "$TargetPath"
      mount -t overlay overlay -o rw,lowerdir="$LowerList",upperdir="$UpperPath",workdir="$WorkPath" "$TargetPath"
    ;;
  esac
}

#
# create new snapshot-layer
#
# - unmount layers, except for first snapshot 
# - make lower-layer from target- or form upper-directory (on first snapshot)
# - create new empty upper directory
# - remount layers
#

ls_snapshot() {
  setPoolVars

  # select mode
  case $LSMode in
    1)
      ls_snapshot_mode1
    ;;
    2)
      ls_snapshot_mode2
    ;;
  esac
  
  # mount it
  ls_mount
}

 # two-layer-mode
ls_snapshot_mode1() {
  # check 
  if mode1First
  then
    # create pool dir
    mkdir -p "$PoolPath"
    
    # create work dir
    mkdir "$WorkPath"

    # create upper dir
    mkdir "$UpperPath"

    # make target dir the lower dir
    mv    "$TargetPath" "$LowerPath"
    
    # create new target dir as mountpoint
    mkdir "$TargetPath"
  else
    # unmount target dir
    umount "$TargetPath"
    
    # create work2 dir
    mkdir "$WorkPath"2

    # create upper2 dir
    mkdir "$UpperPath"2
  fi
}

# unlimited mode
ls_snapshot_mode2() {
  # initial or consecutive snapshot?
  if [ ! -d "$PoolPath" ]
  then
    # create pool dir
    mkdir -p "$PoolPath"
    
    # create work dir
    mkdir "$WorkPath"
    
    # make target dir the mew lower dir
    mv    "$TargetPath" "$LowerPath"
    
    # create new target dir as mountpoint
    mkdir "$TargetPath"
  else
    # unmount target dir
    umount "$TargetPath"
    
    # make target dir the mew lower dir
    mv    "$UpperPath" "$LowerPath"
  fi

  # create upper dir anyway
  mkdir "$UpperPath"
}

#
# restore layer
#
# - let user select layer-Id to restore
# - merge layer-after-layer into lowest layer
# - make lowest layer the new target dir
# - clean up
#

ls_restore() {
  # show status screen first
  ls_status
  
  # get user input, which snapshot to restore
  read -p "Snapshot ID to restore: " toLayerID
  
  # confirm
  read -p "Enter 'restore' to confirm: " confirmation
  if [ ! "$confirmation" == "restore" ]; then
    echo "aborting."
    return 2
  fi
  
  # unmount and remove target
  umount "$TargetPath"
  rmdir  "$TargetPath"
  
  # initialize iterator
  i=1
  
  # iterate through lower-dirs
  for f in "$PoolPath/lower-"*; do
    if [ "$i" == 1 ]; then
      # remember lowest layer
      LowestPath="$f"
    else
      # merge upper layers into remembered lowest it
      mergeLayersByPath "$f/" "$LowestPath"
    fi
    
    # check if target-layer reached
    if [ "$i" == "$toLayerID" ]
    then
      # stop merging
      break
    fi
    
    # increase iterator
    i=$(expr $i + 1)
  done
  
  # make merged dir the target dir
  mv "$LowestPath" "$TargetPath"

  # remove leftovers
  rm -R "$PoolPath"
}

#
# merge layers
#
# - ask for layers to merge
# - merge
#

ls_merge() {
  # show status screen first
  ls_status

  # get user input, which layers to merge
  read -p "Merge layers starting from: " fromLayerID
  read -p "Merge layers ending with: " toLayerID
  
  # confirm
  echo "All layers between and including layers $fromLayerID and $toLayerID will be merged into layer $toLayerID."
  read -p "Enter 'merge' to confirm: " confirmation
  if [ ! "$confirmation" == "merge" ]; then
    echo "aborting."
    return 2
  fi
  
  # find toLayer-path
  setToLayerPath
  
  # initialize iterator
  i=1
  
  # iterate through lower-dirs
  for f in "$PoolPath/lower-"*
  do
    # check if layer is affected
    if [ "$i" -ge "$fromLayerID" ] && [ "$i" -lt "$toLayerID" ]
    then
      # merge
      mergeLayersByPath $f $toLayerPath
    elif [ "$i" -ge "$toLayerID" ]
    then
      # break if last layer reached
      break
    fi
    
    # increase iterator
    i=$(expr $i + 1)
  done
  
  # feedback
  echo "done"
}


#############
#############
##         ##
## HELPERS ##
##         ##
#############
#############


mode1First() {
  if [ ! -d $(echo "$UpperPath"2) ]
  then
    return 1
  else
    return 2
  fi
}


# choose layersnap mode fitting the host-system
setMode() {
  # try to check by ubuntu-version first, then by kernel-version
  if [ "$(cat /etc/issue | grep -c Ubuntu)" -gt "0" ]
  then
    ubuntuMainVersion=$(cat /etc/lsb-release | grep DISTRIB_RELEASE | cut -c 17- | cut -d "." -f1)
    ubuntuSubVersion=$(cat /etc/lsb-release | grep DISTRIB_RELEASE | cut -c 17- | cut -d "." -f2)
  else
    kernelMainVersion=$(uname -r | cut -d "." -f1)
    kernelSubVersion=$(uname -r | cut -d "." -f2)
  fi
  
  # set layersnap-mode
  if [ "$ubuntuMainVersion" -ge "14" ] && [ "$ubuntuSubVersion" -ge "04" ]
  then
    LSMode="2"
  elif   [ "$ubuntuMainVersion" -ge "12" ] && [ "$ubuntuSubVersion" -ge "04" ]
  then
    LSMode="1"
  elif [ "$kernelMainVersion" == "4" ]
  then
    LSMode="2"
  elif [ "$kernelMainVersion" == "3" ]   && [ "$kernelSubVersion" -ge "18" ]
  then
    LSMode="1"
  else
    LSMode="0"
  fi
}

# get human readable total size of directory
sizeOfDir() { # (pathname)
  # get dirname
  location=$(dirname $(realpath $1))
  
  # get basename
  name=$(basename $(realpath $1))
  
  # generate cache path out of dirname and basename
  sizeCachePath="$location/.size_of_$name"
  
  # check if dir-size already been cached
  if [ -e "$sizeCachePath" ]
  then
    # read size from cache
    echo "$(cat "$sizeCachePath")"
  else
    # calculate size
    dirSize=$(du -sch $1 | head -n 1 | cut -d "	" -f1 )
    
    # write cache
    echo "$dirSize" > $sizeCachePath
    
    # echo size
    echo "$dirSize"
  fi 
}

# output number and pluralized version of word if needed
pluralize() { # (word, count)
 echo "$2 $1$(if [ "$2" != "1" ]; then echo "s"; fi)"
}

# compose status line of layer
layerStatusLine() { # (count, path)
  if [ "$3" != "upper" ]
  then
    # lower layers
    LayerDate=$(date -d @$(basename $2 | cut -c 7-) "$DisplayDateFormat")
  else
    # upper layer
    LayerDate=$(printf "%${#LayerDate}s" "now")
  fi
  LayerFileCount=$(find $2 -type f | wc -l)
  echo "layer $(printf "%${#LayerCount}d" $1) from $LayerDate with $(sizeOfDir "$2") in $(pluralize "file" $LayerFileCount)"
}

# set all the variables needed for working with a layer-pool
setPoolVars() {
  # check if pool is mounted
  if mount | grep $TargetPath > /dev/null
  then
    PoolMounted="true"
  else
    PoolMounted="false"
  fi

  # date in format suitable for use in pathname
  Now=$(date "$DateFormat")
  
  # whole path with date
  LowerPath="$PoolPath/lower-$Now"
  
  # path to upper dir
  UpperPath="$PoolPath/upper"
  
  # path to work dir
  WorkPath="$PoolPath/work"
  
  # total lower-layer-count
  LayerCount=$(find "$PoolPath" -name lower-* | wc -l)

  # ":"-seperated list of layer-paths
  LowerList=""
  for f in "$PoolPath/lower-"*
  do
    LowerList="$(realpath "$f"):$LowerList"
  done
  LowerList=${LowerList::-1}
  
  # calculate number of still available layers
  if [ "$LSMode" == "2" ]
  then
    LayersAvailable="Unlimited"
  else
    LayersAvailable=$(expr "$LSMode" - "$LayerCount")
  fi
}

# used by --merge
setToLayerPath() {
  i=1
  for f in "$PoolPath/lower-"*
  do
    if [ "$i" == "$toLayerID" ]
    then
      toLayerPath="$f"
      break
    fi
    i=$(expr $i + 1)
  done
}

# sets LowerList-variable 
setLowerList() { # (from-ID, to-ID)
  # check if params are set and are integers
  if [[ "$1" =~ "^[0-9]+$" ]] && [[ "$1" =~ "^[0-9]+$" ]]
  then
    # if params are set, use them
    from="$1"
    to="$2"
  else
    # unless params are set, select all layers
    from="1"
    to="999999999"
  fi
  
  # reset LowerList
  LowerList=""
  
  # reset iterator
  i=1
  
  # iterate through lower paths
  for f in "$PoolPath/lower-"*
  do
    # check if layer is within selected range
    if [ "$i" -ge "$from" ] && [ "$i" -le "$to" ]
    then
      # add layers absolute path to the LowerList in the correct order for overlayfs-syntax
      LowerList="$(realpath "$f"):$LowerList"
    fi
    # raise iterator anyway
    i=$(expr $i + 1)
  done
  
  # remove trailing colon
  LowerList=${LowerList::-1}
}

# merges one directory into another, overwriting existing files 
mergeLayersByPath() { # (fromLayerPath, toLayerPath)
  echo "merging $1 into $2"
  rsync --remove-source-files "$1/"* "$2"
  # find "$1/"* -type d -empty -delete
  
  # displays message if layer has not been emptied and deleted completely
  rmdir "$1"
}

# parse request params
parseRequest() { # ($*)
  ACTION="status"
  while [[ $# -gt 1 ]]
  do
    key="$1"
    case $key in
      -s|--snapshot)
        ACTION="snapshot"
        shift
      ;;

      -c|--checkout)
        ACTION="checkout"
        shift
      ;;

      -r|--restore)
        ACTION="restore"
        shift
      ;;

      -m|--merge)
        ACTION="merge"
        shift
      ;;
    esac
  done

  # last param
  if [ -n "$1" ]
  then
    TargetPath=$(realpath $1)
    #TargetPath="$(pwd)/$1"
  else
    echo "ERROR: please provide a target-dir!"
  fi
}


###############
###############
##           ##
## BOOTSTRAP ##
##           ##
###############
###############


# call bootstrapper and pass request params
ls_bootstrap $*











