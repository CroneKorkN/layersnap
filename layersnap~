#!/bin/bash

# layersnap
# 
# overlayfs- and rsync-based simple snapshots
#
# - ls_bootstrap is called at the EOF
# - ls_bootstrap calls parseRequest and calls the appropriate controller
# - controller uses helpers to do the job
#
# todo
# ubuntu 12.04 syntax


##############
##############
##          ##
##  ROUTER  ##
##          ##
##############
##############


#
# status, prepare, snapshot, merge or restore?
#

ls_bootstrap() {
  parseRequest
  
  # basic paths and vars
  TargetName="$(basename $TargetPath)"
  PoolPath="$(dirname $TargetPath)/.layersnap/$TargetName"
  DateFormat="+%s"
  DisplayDateFormat="+%d.%m.%Y %H:%M:%S"


  case $ACTION in

    # status
    status)
      if [ ! -d "$PoolPath" ]
      then
        echo "$TargetPath is not layersnapped."
      else
        ls_status
      fi
    ;;

    # snapshot
    snapshot)
      ls_snapshot
    ;;
    
    #merge
    merge)
      if [ -d "$PoolPath" ]
      then
        ls_merge
      else
        echo ERROR: $TargetPath is not layersnapped, so nothing to merge!
      fi
    ;;
    
    #restore
    restore)
      if [ -d "$PoolPath" ]
      then
        ls_restore
      else
        echo ERROR: $TargetPath is not layersnapped, so nothing to restore!
      fi
    ;;
  esac
}


###################
###################
##               ##
##  CONTROLLERS  ##
##               ##
###################
###################


# 
# show status and layers
#

ls_status() {
  setPoolVars
  if [ ! "$PoolMounted" == "true" ]; then
    ls_mount
    echo "layers have just been mounted."
  fi

  echo "LAYERSNAP: $TargetPath" consists of $(expr $LayerCount + 1) layers.
  
  i=1; for f in "$PoolPath/lower-"*; do
    layerStatusLine $i $f
    i=$(expr $i + 1)
  done
  layerStatusLine $(expr $LayerCount + 1) $UpperPath upper
}

#
# mount pool
#

ls_mount() {
  setPoolVars
  
  # mount
  mount -t overlay overlay -olowerdir="$LowerList",upperdir="$UpperPath",workdir="$WorkPath" "$TargetPath"
}

#
# create new snapshot-layer
#
# - unmount layers, except for first snapshot 
# - make lower-layer from target- or form upper-directory (on first snapshot)
# - create new empty upper directory
# - remount layers
#

ls_snapshot() {
  setPoolVars
  
  if [ ! -d "$PoolPath" ]; then
    ls_snapshot_first
  else
    ls_snapshot_consecutive
  fi
  mkdir "$UpperPath"
  ls_mount
}

ls_snapshot_first() {
  mkdir -p "$PoolPath"
  mkdir "$WorkPath"
  mv    "$TargetPath" "$LowerPath"
  mkdir "$TargetPath"
}

ls_snapshot_consecutive() {
  umount "$TargetPath"
  mv "$UpperPath" "$LowerPath"
}

#
# restore layer
#
# - let user select layer-Id to restore
# - merge layer-after-layer into lowest layer
# - make lowest layer the new target dir
# - clean up
#

ls_restore() {
  ls_status
  read -p "Snapshot ID to restore: " toLayerID

  umount "$TargetPath"
  rmdir  "$TargetPath"
    
  i=1
  for f in "$PoolPath/lower-"*; do
    # remember lowest layer and merge all upper layer into it
    if [ "$i" == 1 ]; then
      LowestPath="$f"
    else
      mergeLayersByPath "$f/" "$LowestPath"
    fi
    if [ "$i" == "$toLayerID" ]; then break; fi
    i=$(expr $i + 1)
  done
  
  mv "$LowestPath" "$TargetPath"
  rm -R "$PoolPath"
}


#
# merge layers
#
# - ask for layers to merge
# - merge
#

ls_merge() {
  ls_status
  
  read -p "Merge layers starting from: " fromLayerID
  read -p "Merge layers ending with: " toLayerID
  echo "All layers between and including layers $fromLayerID and $toLayerID will be merged into layer $toLayerID."
  read -p "Enter 'merge' to confirm: " confirmation
  if [ ! "$confirmation" == "merge" ]; then
    echo "aborting."
    #return 2
  fi
  
  # find toLayer-path
  setToLayerPath
  
  i=1
  for f in "$PoolPath/lower-"*
  do
    if [ "$i" -ge "$fromLayerID" ] && [ "$i" -lt "$toLayerID" ]
    then
      mergeLayersByPath $f $toLayerPath
    elif [ "$i" -ge "$toLayerID" ]
    then
      break
    fi
    i=$(expr $i + 1)
  done
  
  echo "done"
}


#############
#############
##         ##
## HELPERS ##
##         ##
#############
#############


# get human readable total size of directory
sizeOfDir() { # (pathname)
  location=$(dirname $(realpath $1))
  name=$(basename $(realpath $1))
  sizeCachePath="$location/.size_of_$name"
  if [ ! -e "$sizeCachePath" ]
  then
    echo $(du -sch $1 | head -n 1 | cut -d "	" -f1 ) > $sizeCachePath
  fi
  echo "$(cat "$sizeCachePath")"
}

# output number and pluralized version of word if needed
pluralize() { # (word, count)
 echo "$2 $1$(if [ "$2" != "1" ]; then echo "s"; fi)"
}

# compose status line of layer
layerStatusLine() { # (count, path)
  if [ "$3" != "upper" ]
  then
    # lower layers
    LayerDate=$(date -d @$(basename $2 | cut -c 7-) "$DisplayDateFormat")
  else
    # upper layer
    LayerDate=$(printf "%${#LayerDate}s" "now")
  fi
  LayerFileCount=$(find $2 -type f | wc -l)
  echo "layer $(printf "%${#LayerCount}d" $1) from $LayerDate with $(sizeOfDir "$2") in $(pluralize "file" $LayerFileCount)"
}

# set all the variables needed for working with a layer-pool
setPoolVars() {
  # display "not " if Pool is not mounted
  if mount | grep $TargetPath > /dev/null
  then
    PoolMounted="true"
  else
    PoolMounted="false"
  fi

  # date in format suitable for use in pathname
  Now=$(date "$DateFormat")
  
  # whole path with date
  LowerPath="$PoolPath/lower-$Now"
  
  # path to upper dir
  UpperPath="$PoolPath/upper"
  
  # path to work dir
  WorkPath="$PoolPath/work"
  
  # total lower-layer-count
  LayerCount=$(find "$PoolPath" -name lower-* | wc -l)

  # ":"-seperated list of layer-paths
  LowerList=""
  for f in "$PoolPath/lower-"*
  do
    LowerList="$(realpath "$f"):$LowerList"
  done
  LowerList=${LowerList::-1}
}

# used by --merge
setToLayerPath() {
  i=1
  for f in "$PoolPath/lower-"*
  do
    if [ "$i" == "$toLayerID" ]
    then
      toLayerPath="$f"
      break
    fi
    i=$(expr $i + 1)
  done
}

# sets LowerList-variable 
setLowerList() { # (from-ID, to-ID)
  if [[ "$1" =~ "^[0-9]+$" ]] && [[ "$1" =~ "^[0-9]+$" ]]
  then
    from="$1";to="$2"
  else
    from="1";to="999999999"
  fi

  LowerList=""
  i=1
  for f in "$PoolPath/lower-"*
  do
    if [ "$i" >= "$from" ] && [ "$i" <= "$to" ]
    then
      LowerList="$(realpath "$f"):$LowerList"
    fi
    i=$(expr $i + 1)
  done
  LowerList=${LowerList::-1}
}

# merges one directory into another, overwriting existing files 
mergeLayersByPath() { # (fromLayerPath, toLayerPath)
  echo "merging $1 into $2"
  rsync --remove-source-files "$1/"* "$2"
  # find "$1/"* -type d -empty -delete
  
  # displays message if layer has not been emptied and deleted completely
  rmdir "$1"
}

     
# parse request params
parseRequest() { # ()
  while [ $# -gt 1 ]
  do
    echo $#
    echo $1
    shift
  done

  read

  ACTION=status
  while [ $# -gt 1 ]
  do
    key="$1"
    case $key in
      -m|--mount)
        ACTION=mount 
        shift
      ;;

      -s|--snapshot)
        ACTION=snapshot
        shift
      ;;

      -c|--checkout)
        ACTION=checkout
        shift
      ;;

      -r|--restore)
        ACTION=restore
        VALUE="$2"
        shift
      ;;

      -m|--merge)
        ACTION=merge
        shift
      ;;
    esac
  done

  # last param
  if [[ -n $1 ]]; then
    #TargetPath=$(realpath $1) # bug: follows symlink
    TargetPath="$(pwd)/$1"
  else
    echo "ERROR: please provide a target-dir!"
  fi
}


###############
###############
##           ##
## BOOTSTRAP ##
##           ##
###############
###############


ls_bootstrap












