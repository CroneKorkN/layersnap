#!/bin/bash

# layersnap
# 
# overlayfs- and rsync-based simple snapshots
#
# programme-structure:
# - ls_bootstrap is called at the EOF
# - ls_bootstrap calls parse_request and calls the appropriate controller
# - controller uses helpers to do the job
#
# convention:
# - GlobalVariable
# - localVariable
# - function_name()
#
# terminology:
# - layer: one single directory
# - snapshot: a directory with all previous layers
#
# todo:
# - ubuntu 12.04 syntax
# - $((2 ** 4))


##############
##############
##          ##
##  ROUTER  ##
##          ##
##############
##############


#
# status, prepare, snapshot, merge or restore?
#

ls_bootstrap() { # (request)
  # parse request parameters
  parse_request $*
  
  # set mode depending on host-system
  set_mode

  # basic paths and vars
  TargetName="$(basename $TargetPath)"
  PoolPath="$(dirname $TargetPath)/.layersnap/$TargetName"
  DateFormat="+%s"
  DisplayDateFormat="+%d.%m.%Y %H:%M:%S"
  
  # exit with message if target is not layersnapped
  if [ ! -d "$PoolPath" ]
  then
    echo ABORTING: $TargetPath is not layersnapped, so nothing to $ACTION!
    exit
  fi
  
  # jeahjeahjeah
  case $ACTION in

    status)
      ls_status
    ;;

    snapshot)
      ls_snapshot
    ;;
    
    merge)
      ls_merge
    ;;
    
    restore)
      ls_restore
    ;;
  esac
}


###################
###################
##               ##
##  CONTROLLERS  ##
##               ##
###################
###################


# 
# show status and layers
#

ls_status() {
  set_pool_vars

  # ensure target is mounted
  ls_mount
    
  # display summerizing information
  echo "$TargetPath uses $(expr $LayerCount + 1) layers. $(pluralize "layer" $LayersAvailable) available."
  
  # show detailed inforamtion for each layer
  i=1
  for f in "$PoolPath/lower-"*
  do
    layer_status_line $i $f
    i=$(expr $i + 1)
  done
  
  # show final status line for upper directory
  layer_status_line $(expr $LayerCount + 1) $UpperPath upper
}

#
# mount pool
#

ls_mount() {
  if is_pool_mounted
  then
    return 1
  fi
  
  # select mode
  case $LSMode in

    legacy)
      if is_first_snapshot
      then
        mount -t overlayfs -o rw,lowerdir="$LowerList",upperdir="$UpperPath" overlayfs "$TargetPath"
      else
        mount -t overlayfs -o rw,lowerdir="$LowerList",upperdir="$UpperPath" overlayfs "$MergePath"
        mount -t overlayfs -o rw,lowerdir="$MergePath",upperdir="$Upper2Path" overlayfs "$TargetPath"
      fi
    ;;
    
    unlimited)
      mount -t overlay overlay -o rw,lowerdir="$LowerList",upperdir="$UpperPath",workdir="$WorkPath" "$TargetPath"
    ;;
  esac

  echo "layers have just been mounted."
}

#
# create new snapshot-layer
#
# - unmount layers, except for first snapshot 
# - make lower-layer from target- or form upper-directory (on first snapshot)
# - create new empty upper directory
# - remount layers
#

ls_snapshot() {
  set_pool_vars

  # select mode
  case $LSMode in
    legacy)
      ls_snapshot_legacy
    ;;
    unlimited)
      ls_snapshot_unlimited
    ;;
  esac
  
  # mount it
  ls_mount
}

 # two-layer-mode
ls_snapshot_legacy() {
  # check 
  if is_first_snapshot
  then
    # create pool-, work-, upper-dir
    mkdir -p "$PoolPath" "$UpperPath" 

    # make target dir the lower dir
    mv    "$TargetPath" "$LowerPath"
    
    # recreate target-dir as mountpoint
    mkdir "$TargetPath"
  else
    # unmount target dir
    umount "$TargetPath"

    # create upper2 dir
    mkdir "$Upper2Path"
  fi
}

# unlimited mode
ls_snapshot_unlimited() {
  # initial or consecutive snapshot?
  if is_first_snapshot
  then
    # create pool dir
    mkdir -p "$PoolPath"
    
    # create work dir
    mkdir "$WorkPath"
    
    # make target dir the mew lower dir
    mv    "$TargetPath" "$LowerPath"
    
    # create new target dir as mountpoint
    mkdir "$TargetPath"
  else
    # unmount target dir
    umount "$TargetPath"
    
    # make target dir the mew lower dir
    mv    "$UpperPath" "$LowerPath"
  fi

  # create upper dir anyway
  mkdir "$UpperPath"
}

#
# restore layer
#
# - let user select layer-Id to restore
# - merge layer-after-layer into lowest layer
# - make lowest layer the new target dir
# - clean up
#

ls_restore() {
  # show status screen first
  ls_status
  
  # get user input, which snapshot to restore
  read -p "Snapshot ID to restore: " destinationLayerID
  
  # confirm
  read -p "Enter 'restore' to confirm: " confirmation
  if [ ! "$confirmation" == "restore" ]; then
    echo "aborting."
    exit 1
  fi
  
  # unmount and remove target
  umount "$TargetPath"
  rmdir  "$TargetPath"
  
  # initialize iterator
  i=1
  
  # iterate through lower-dirs
  for f in "$PoolPath/lower-"*; do
    if [ "$i" == 1 ]; then
      # remember lowest layer
      LowestPath="$f"
    else
      # merge upper layers into remembered lowest it
      merge_layers_by_path "$f/" "$LowestPath"
    fi
    
    # check if target-layer reached
    if [ "$i" == "$destinationLayerID" ]
    then
      # stop merging
      break
    fi
    
    # increase iterator
    i=$(expr $i + 1)
  done
  
  # make merged dir the target dir
  mv "$LowestPath" "$TargetPath"

  # remove leftovers
  rm -R "$PoolPath"
}

#
# merge layers
#
# - ask for layers to merge
# - merge
#

ls_merge() {
  # show status screen first
  ls_status

  # get user input, which layers to merge
  read -p "Merge layers starting from: " fromLayerID
  read -p "Merge layers ending with: " destinationLayerID
  
  # confirm
  echo "All layers between and including layers $fromLayerID and $destinationLayerID will be merged into layer $destinationLayerID."
  read -p "Enter 'merge' to confirm: " confirmation
  if [ ! "$confirmation" == "merge" ]; then
    echo "aborting."
    return 2
  fi
  
  # find destinationLayer-path
  set_destination_layer_path
  
  # initialize iterator
  i=1
  
  # iterate through lower-dirs
  for f in "$PoolPath/lower-"*
  do
    # check if layer is affected
    if [ "$i" -ge "$fromLayerID" ] && [ "$i" -lt "$destinationLayerID" ]
    then
      # merge
      merge_layers_by_path $f $destinationLayerPath
    elif [ "$i" -ge "$destinationLayerID" ]
    then
      # break if last layer reached
      break
    fi
    
    # increase iterator
    i=$(expr $i + 1)
  done
  
  # feedback
  echo "done"
}


#############
#############
##         ##
## HELPERS ##
##         ##
#############
#############


# if upper2-dir doesnt exist, you're doing the first snapshot 
is_first_snapshot() {
  if [ ! -d "$PoolPath" ]
  then
    return 0 # true, first
  else
    return 1 # fasle, consecutive
  fi
}

# is second and last legacy-mode snapshot; in unlimited mode, there ist never a last snapshot
is_last_snapshot() {
  if [ -d "$PoolPath" ]  && [ ! -d "$Upper2Path" ]
  then
    return 0 # true, last
  else
    return 1 # fasle, other
  fi
}

# choose layersnap mode fitting the host-system
set_mode() {
  # try to check by ubuntu-version first, then by kernel-version
  if [ "$(cat /etc/issue | grep -c Ubuntu)" -gt "0" ]
  then
    ubuntuMainVersion=$(cat /etc/lsb-release | grep DISTRIB_RELEASE | cut -c 17- | cut -d "." -f1)
    ubuntuSubVersion=$(cat /etc/lsb-release | grep DISTRIB_RELEASE | cut -c 17- | cut -d "." -f2)
  else
    kernelMainVersion=$(uname -r | cut -d "." -f1)
    kernelSubVersion=$(uname -r | cut -d "." -f2)
  fi
  
  # set layersnap-mode
  if [ "$ubuntuMainVersion" -ge "14" ] && [ "$ubuntuSubVersion" -ge "04" ]
  then
    LSMode="unlimited"
  elif   [ "$ubuntuMainVersion" -ge "12" ] && [ "$ubuntuSubVersion" -ge "04" ]
  then
    LSMode="legacy"
  elif [ "$kernelMainVersion" == "4" ]
  then
    LSMode="unlimited"
  elif [ "$kernelMainVersion" == "3" ]   && [ "$kernelSubVersion" -ge "18" ]
  then
    LSMode="legacy"
  else
    echo "ABORTING: Sorry, but your System is not capable of running layersnap."
    echo "Layersnap depends on overlayfs, which was included in kernel 3.18 and extended by support of multiple lower-layers in 4.0. Besides that, Ubuntu supports overlayfs partly since at least 12.04 and fully since at least 14.04"
    exit
  fi
  
  echo mode $LSMode # debug
}

# get human readable total size of directory
size_of_dir() { # (pathname)
  # get dirname
  location=$(dirname $(realpath $1))
  
  # get basename
  name=$(basename $(realpath $1))
  
  # generate cache path out of dirname and basename
  sizeCachePath="$location/.size_of_$name"
  
  # check if dir-size already been cached
  if [ -e "$sizeCachePath" ]
  then
    # read size from cache
    echo "$(cat "$sizeCachePath")"
  else
    # calculate size
    dirSize=$(du -sch $1 | head -n 1 | cut -d "	" -f1 )
    
    # write cache
    echo "$dirSize" > $sizeCachePath
    
    # echo size
    echo "$dirSize"
  fi 
}

# output number and pluralized version of word if needed
pluralize() { # (word, count)
 echo "$2 $1$(if [ "$2" != "1" ]; then echo "s"; fi)"
}

# compose status line of layer
layer_status_line() { # (count, path)
  if [ "$3" != "upper" ]
  then
    # lower layers
    LayerDate=$(date -d @$(basename $2 | cut -c 7-) "$DisplayDateFormat")
  else
    # upper layer
    LayerDate=$(printf "%${#LayerDate}s" "now")
  fi
  LayerFileCount=$(find $2 -type f | wc -l)
  echo "layer $(printf "%${#LayerCount}d" $1) from $LayerDate with $(size_of_dir "$2") in $(pluralize "file" $LayerFileCount)"
}

# check if pool is mounted
is_pool_mounted() {
  echo 
  if mount | grep $TargetPath > /dev/null
  then
    return 0 # true
  else
    return 1 # false
  fi
}

# set all the variables needed for working with a layer-pool
set_pool_vars() {
  # date in format suitable for use in pathname
  Now=$(date "$DateFormat")
  
  # whole path with date
  LowerPath="$PoolPath/lower-$Now"
  
  # path to upper dirs
  UpperPath="$PoolPath/upper"
  Upper2Path="$PoolPath/upper2"
  
  # path to work dir
  WorkPath="$PoolPath/work"
  
  # total lower-layer-count
  LayerCount=$(find "$PoolPath" -name lower-* | wc -l)

  # ":"-seperated list of layer-paths
  LowerList=""
  for f in "$PoolPath/lower-"*
  do
    LowerList="$(realpath "$f"):$LowerList"
  done
  LowerList=${LowerList::-1}
  
  set_layers_available
}

# calculate number of still available layers
set_layers_available() {
  if [ "$LSMode" == "unlimited" ]
  then
    LayersAvailable="Unlimited"
  elif [ "$LSMode" == "legacy" ]
  then
    if is_first_snapshot
    then
      LayersAvailable="2"
    else
      if is_last_snapshot
      then
        LayersAvailable="1"
      else
        LayersAvailable="0"
      fi
    fi
  fi
}

# used by --merge
set_destination_layer_path() {
  i=1
  for f in "$PoolPath/lower-"*
  do
    if [ "$i" == "$destinationLayerID" ]
    then
      destinationLayerPath="$f"
      break
    fi
    i=$(expr $i + 1)
  done
}

# sets LowerList-variable 
set_lower_list() { # (from-ID, to-ID)
  # check if params are set and are integers
  if [[ "$1" =~ "^[0-9]+$" ]] && [[ "$1" =~ "^[0-9]+$" ]]
  then
    # if params are set, use them
    from="$1"
    to="$2"
  else
    # unless params are set, select all layers
    from="1"
    to="999999999"
  fi
  
  # reset LowerList
  LowerList=""
  
  # reset iterator
  i=1
  
  # iterate through lower paths
  for f in "$PoolPath/lower-"*
  do
    # check if layer is within selected range
    if [ "$i" -ge "$from" ] && [ "$i" -le "$to" ]
    then
      # add layers absolute path to the LowerList in the correct order for overlayfs-syntax
      LowerList="$(realpath "$f"):$LowerList"
    fi
    # raise iterator anyway
    i=$(expr $i + 1)
  done
  
  # remove trailing colon
  LowerList=${LowerList::-1}
}

# merges one directory into another, overwriting existing files 
merge_layers_by_path() { # (fromLayerPath, destinationLayerPath)
  echo "merging $1 into $2"
  rsync --remove-source-files "$1/"* "$2"
  # find "$1/"* -type d -empty -delete
  
  # displays message if layer has not been emptied and deleted completely
  rmdir "$1"
}

# parse request params
parse_request() { # ($*)
  ACTION="status"
  while [[ $# -gt 1 ]]
  do
    key="$1"
    case $key in
      s|snapshot)
        ACTION="snapshot"
        shift
      ;;

      c|checkout)
        ACTION="checkout"
        shift
      ;;

      r|restore)
        ACTION="restore"
        shift
      ;;

      m|merge)
        ACTION="merge"
        shift
      ;;
      
      status)
        ACTION="status"
        shift
      ;;
    esac
  done

  # last param
  if [ -n "$1" ]
  then
    TargetPath=$(realpath $1)
    #TargetPath="$(pwd)/$1"
  else
    echo "ERROR: please provide a target-dir!"
  fi
}


###############
###############
##           ##
## BOOTSTRAP ##
##           ##
###############
###############

# call bootstrapper and pass request params
ls_bootstrap $*










